#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <math.h>
#include <stdbool.h>

/**
 * @brief Функция присваивает целочисленное значение переменной
 * @param - сообщение для пользователя
 * @return целочисленная цифра
*/
int scan_f(const char* const message);

/**
 * @brief Функция выделяет память под массив
 * @param size длина массива
 * @return array указатель на пустой массив
*/
int* get_array(const int size);

/**
 * @brief Функция заполняет массив элементами, которые вводит пользователь
 * @param array указатель на заполняемый массив
 * @param size длина массива
*/
void FillArrayUser(int* const array, const size_t size);

/**
 * @brief Функция заполняет массив рандомными числами в диапазоне [begin : end]
 * @param array указатель на заполняемый массив
 * @param size длина массива
*/
void FillArrayRandom(int* const array, const size_t size);

/**
 * @brief Функция присваивает переменной целочисленное значение и проверяет его на положителность
 * @return number положительное число
*/
size_t get_size();

/**
 * @brief Функция выводит массив на экран
 * @param array указатель на заполняемый массив
 * @param size длина массива
*/
void print_array(const int* const  array, const size_t size);

/**
 * @brief Функция копирующая элементы одного массива в другой
 * @param Current исходный массив
 * @param Copy пустой массив
 * @param size длина массива
*/
void copy_array(int* const current, int* copy, const size_t size);

/**
 * @brief Функция меняет предпоследний элемент массива на максимальный по модулю.
 * @param array указатель на массив
 * @param size размерность массива
 * @return результат
*/
int *task1(int* array, const size_t size);

/**
 * @brief Фунция находит количество тех элементов, значения которых делятся на заданное число N без остатка.
 * @param array указатель на массив
 * @param size размерность массива
 * @return 0
*/
int task2(const int* const array, const size_t size);

/**
 * @brief Функция находит номер первой пары соседних элементов с разными знаками.
 * @param array указатель на массив
 * @param size размерность массива
 * @return Итоговый ответ для третьего задания
*/
int task3(const int* const array, const size_t size);

/**
 * @brief Функция, освобождающая массив
 * @param array указатель на массив
*/
void free_array(int* array);

/**
 * @brief Функция проверяет концы промежутка
 * @param begin начало диапазона
 * @param end конец диапазона 
*/
void CheckRange(const int begin, const int end);

/**
 * @brief структура хранит константы, указывающие выбор пользователя заполнить массив
 * @brief User хранит значение, вызывающее ввод массива вручную
 * @brief Random хранит значение, вызывающее ввод массива случайными числами
*/
enum Choices
{
    User = 1,
    Random = 2
};

/**
 * @brief точка входа в программу
 * @return код ошибки (0 - успех)
 */
int main() 
{
    srand(time(NULL)); 
    size_t size = get_size(); 
    int *Array = get_array(size);
    int choice = scan_f("Выберите способ заполнения массива\n 1. Вручную, 2. Автозаполнение\n");
    switch ((enum Choices)choice)
    {
      case User:
              FillArrayUser(Array, size);
          break;
      case Random:
              FillArrayRandom(Array, size);
          break;
      default:
          puts("Insert a valid choice!\n");
          return 1;
    }
    int* new_array_1 = get_array(size);
    copy_array(Array, new_array_1, size);
    print_array(task1(new_array_1, size), size);
    printf("Second task: %d\n", task2(Array, size));
    printf("third task: %d\n", task3(Array, size));
    free_array(Array);
    free_array(new_array_1);
    return 0;
}

int scan_f(const char* const message)
{
    int value = 0;
    printf("%s", message);
    int result = scanf("%d", &value);
    if (result != 1)
    {
        errno = EIO;
        perror("Error :");
        abort();
    }
    return value;
}

size_t get_size()
{
   int size =  scan_f("Введите размер массива: ");
   if (size <= 0)
   {
       errno = ERANGE;
       perror("Error :");
       abort();
   }

   return (size_t)size;
}

int* get_array(const int size)
{
    int* array = malloc(size * sizeof(int));
    if (NULL == array)
    {
        errno = ENOMEM;
        perror("Error :");
        abort();
    }
    return array;
}

void CheckRange(const int begin, const int end)
{
    if (begin > end)
    {
        puts("error ");
        abort();
    }
}

void FillArrayUser(int* const array, const size_t size)
{
    puts("Введите элементы массива: ");
    for (size_t i = 0; i < size; i++)
    {
        array[i] = scan_f("Введите элемент = ");           
    }
}

void FillArrayRandom(int *const array, const size_t size) 
{
    const int begin = scan_f("Введите нижнюю границу диапазона: "), end = scan_f("Введите верхнюю границу диапазона: ");
    CheckRange(begin, end);
    for (size_t i = 0; i < size; i++)
    {
        array[i] = begin + rand() % (end - begin + 1);
    }
}

void print_array(const int* const  array, const size_t size)
{
    puts("Элементы массива: ");
    for(size_t i = 0; i < size; i++)
    {
        printf("Элемент %zu = %d\n", i, array[i]);
    }
}

void copy_array(int* const current, int* copy, const size_t size)
{
    for (size_t i = 0; i < size; i++)
    {
        copy[i] = current[i];
    }
}

int *task1( int* array, const size_t size)
{
    int composition = 1;
    for (size_t i = 0; i <= size; i++)
    {
        if ((abs(array[i]) < 5) && (i % 2 == 0))
        {
            composition *= array[i];
        }
    }
    return composition;
}

int task2(const int* const array, const size_t size)
{
    int A = scanf();
    int count = 0;
    for (size_t i = 0; i <= size; i++) 
    {
        if ((array[i] % 2 != 0) && (abs(array[i]) > A))
        {
            count += 1;
        }   
    }
    return count;
}

int task3(const int* const array, const size_t size)
{
    for (size_t i = 0; i <= size; i++) 
    {
        if ((i % 2 != 0) && (array[i] % 3 == 0))
        {
            array[i] = array[i] * i 
        }
    }
    return array;
}

void free_array(int* array)
{
    if (NULL != array)
    {
        free(array);
    }
}
