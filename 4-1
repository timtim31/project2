#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <math.h>
#include <stdbool.h>

/**
* @brief Функция проверки принадлежности вводимого значения к диапазону 
* @param value вводимое значение
* @param begin начало диапазона
* @param end конец диапазона
*/
void checkbelonging(int value, const int begin, const int end);

/**
* @brief Функция выделяет память под массив
* @param size длина массива
* @return array указатель на пустой массив
*/
int* get_array(const int size);

/**
* @brief Функция заполняет массив элементами, которые вводит пользователь
* @param array указатель на заполняемый массив
* @param size длина массива
*/
void FillArrayUser(int* const array, const size_t size);

/**
* @brief Функция заполняет массив рандомными числами в диапазоне [begin : end]
* @param array указатель на заполняемый массив
* @param size длина массива
*/
void FillArrayRandom(int* const array, const size_t size);

/**
* @brief Функция присваивает переменной целочисленное значение и проверяет его на положителность
* @return number положительное число
*/
size_t get_size();

/**
* @brief Функция выводит массив на экран
* @param array указатель на заполняемый массив
* @param size длина массива
*/
void print_array(const int* const  array, const size_t size);

/**
* @brief Функция копирующая элементы одного массива в другой
* @param Current исходный массив
* @param Copy пустой массив
* @param size длина массива
*/
void copy_array(int* const current, int* copy, const size_t size);

/**
* @brief Функция нахождения произведения чётных элементов, значения которых по модулю меньше 5
* @param array указатель на массив
* @param size размерность массива
* @return composition произведение элементов массива, которые удовлетворяют условию задачи
*/
int task1(const int* const array, const size_t size);

/**
* @brief Фунция нахождения количества элементов, значения которых нечетны и по модулю превосходят заданное А
* @param array указатель на массив
* @param size размерность массива
* @return count количество элементов, удовлетворяющих условию задачи
*/
int task2(const int* const array, const size_t size);

/**
* @brief Функция умножения всех чётных элементов массива, кратных 3, на их номера 
* @param array указатель на массив
* @param size размерность массива
* @return Массив, после выполнения поставленных в условии задач
*/
int *task3(const int* const array, const size_t size);

/**
* @brief Функция, освобождающая массив
* @param array указатель на массив
*/
void free_array(int* array);

/**
* @brief Функция проверяет концы диапазона
* @param begin начало диапазона
* @param end конец диапазона 
*/
void CheckRange(const int begin, const int end);

/**
* @brief Функция присваивает целочисленное значение переменной
* @param сообщение для пользователя
* @return целочисленная цифра
*/
int fun_scan(const char* const message);

/**
* @brief Функция проверки ввода на положительное число 
* @return Результат проверки   
*/
int check_fun();

/**
* @brief структура хранит константы, указывающие выбор пользователя заполнения массива
* @brief User хранит значение, вызывающее ввод массива вручную
* @brief Random хранит значение, вызывающее ввод массива случайными числами
*/
enum Choices
{
    User = 1,
    Random = 2
};

/**
* @brief Точка входа в программу  
* @return Вывод 0, если программа работает неверно. Иначе вывод 1  
*/
int main() 
{
    srand(time(NULL)); 
    size_t size = get_size(); 
    int *Array = get_array(size);
    int choice = fun_scan("Выберите способ заполнения массива\n 1. Вручную, 2. Автозаполнение\n");
    switch ((enum Choices)choice)
    {
      case User:
              FillArrayUser(Array, size);
          break;
      case Random:
              FillArrayRandom(Array, size);
          break;
      default:
          puts("Insert a valid choice!\n");
          return 1;
    }
    int* new_array_3 = get_array(size);
    copy_array(Array, new_array_3, size);
    printf("First task: %d\n", task1(Array, size));
    printf("Second task: %d\n", task2(Array, size));
    printf("Third task: ");
    print_array(task3(new_array_3, size), size);
    free_array(Array);
    free_array(new_array_3);
    return 0;
}

void checkbelonging(int value, const int begin, const int end)
{
    if ((value < begin) || value > end))
    {
        printf("Элемент не входит в заданный диапазон");
        abort();
    }
}
size_t get_size()
{
   int size =  fun_scan("Введите размер массива: ");
   if (size <= 0)
   {
       errno = ERANGE;
       perror("Error :");
       abort();
   }

   return (size_t)size;
}

int* get_array(const int size)
{
    int* array = malloc(size * sizeof(int));
    if (NULL == array)
    {
        errno = ENOMEM;
        perror("Error :");
        abort();
    }
    return array;
}

void CheckRange(const int begin, const int end)
{
    if (begin > end)
    {
        puts("error ");
        abort();
    }
}

void FillArrayUser(int* const array, const size_t size)
{
    const int begin = fun_scan("Введите нижнюю границу диапазона: "), end = fun_scan("Введите верхнюю границу диапазона: ");
    puts("Введите элементы массива: ");
    for (size_t i = 0; i < size; i++)
    {
        array[i] = fun_scan("Введите элемент = ");
        void checkbelonging(array[i], begin, end);
    }
}

void FillArrayRandom(int *const array, const size_t size) 
{
    const int begin = fun_scan("Введите нижнюю границу диапазона: "), end = fun_scan("Введите верхнюю границу диапазона: ");
    CheckRange(begin, end);
    for (size_t i = 0; i < size; i++)
    {
        array[i] = begin + rand() % (end - begin + 1);
    }
}

void print_array(const int* const  array, const size_t size)
{
    puts("Элементы массива: ");
    for(size_t i = 0; i < size; i++)
    {
        printf("Элемент %zu = %d\n", i, array[i]);
    }
}

void copy_array(int* const current, int* copy, const size_t size)
{
    for (size_t i = 0; i < size; i++)
    {
        copy[i] = current[i];
    }
}

int task1(const int* const array, const size_t size)
{
    int composition = 1;
    for (size_t i = 0; i < size; i++)
    {
        if ((abs(array[i]) < 5) && (i % 2 == 0))
        {
            composition *= array[i];
        }
    }
    return composition;
}

int task2(const int* const array, const size_t size)
{
    int A = check_fun();
    int count = 0;
    for (size_t i = 0; i <= size; i++) 
    {
        if ((array[i] % 2 != 0) && (abs(array[i]) > A))
        {
            count += 1;
        }   
    }
    return count;
}

int *task3(const int* const array, const size_t size)
{
    for (size_t i = 0; i <= size; i++) 
    {
        if ((i % 2 != 0) && (array[i] % 3 == 0))
        {
            array[i] == array[i] * i;
        }
    }
    return array;
}

void free_array(int* array)
{
    if (NULL != array)
    {
        free(array);
    }
}

int fun_scan(const char* const message)
{
    int value = 0;
    printf("%s", message);
    int result = scanf("%d", &value);
    if (result != 1)
    {
        errno = EIO;
        perror("Error :");
        abort();
    }
    return value;
}

int check_fun() 
{
    int value;
    int result = scanf("%d", &value);
    if (result != 1)
    {
        puts("error");
        abort();
    } 
    return value;
}
